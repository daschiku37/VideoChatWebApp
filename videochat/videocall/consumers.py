#views analogous
import json
from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer
from django.contrib.auth.mixins import LoginRequiredMixin
from .models import (ChatRoom,Participant)

#cant use LoginRequiredDirectly as it takes request.user
#Add userpassestest mixin to allow users only when a room is already created
class VideoCallConsumer(WebsocketConsumer):
    
    def connect(self):
       #extracting the room-id from the link
       #an unique id generated by server
       self.room_id = self.scope['url_route']['kwargs']['room_id']
       currentuser = self.scope['user']._wrapped 
             
    #    _wrapped attribute holds the user info inside the scope 
    #    print(self.scope['user']._wrapped.__dict__)
       
       #Join the room
       async_to_sync(self.channel_layer.group_add)(
           self.room_id,
           self.channel_name 
       )
       
       #Add the channel name to the participant table
       #Add the user to the participants of chat room
       try:
           room = ChatRoom.objects.get(pk=self.room_id)
           participant = Participant.objects.create(user=currentuser,channelname=self.channel_name)
           room.participants.add(participant)
       except Exception as err:
           #If entry was not allowed or some error occured then disconnect
           #print("Error:",err)
           self.disconnect("Not added in room")
       
       #Accept the socket
       self.accept()
       
       #Send the updated username of the user
       self.send(text_data=json.dumps({
           'type':'accepted',
           'user':currentuser.username+self.channel_name,
           'data':{}
       }))
       
       #print(self.scope['user'])
       #print(currentuser.username,": Connected to the WebSocket")
       
    def disconnect(self,close_code):
        #remove the channel layer from the group
        async_to_sync(self.channel_layer.group_discard)(
            self.room_id,
            self.channel_name
        )
        #remove from database too
        try:
            room = ChatRoom.objects.get(pk=self.room_id)
            currentuser = self.scope['user']._wrapped 
            participant = Participant.objects.get(user=currentuser,channelname=self.channel_name)
            room.participants.remove(participant)
            participant.delete()
        except:
            pass
    
    def receive(self,text_data):
        text_data_json = json.loads(text_data)
        type = text_data_json['type']
        
        if(type == 'new-participant'):
            #Add the channelname to the data
            text_data_json['data']['receiverchannelname'] = self.channel_name
            async_to_sync(self.channel_layer.group_send)(
                self.room_id,
                {
                    'type':'newParticipant',
                    'data':text_data_json    
                }
            )
        
        
        if(type == 'ICECandidate' or type =='offer' or type=='answer'):
            #print("Type:",type)
            receiverchannelname = text_data_json['data']['receiverchannelname']
            text_data_json['data']['receiverchannelname'] = self.channel_name
            async_to_sync(self.channel_layer.send)(
                receiverchannelname, 
                {
                    'type':'ByPassFunction',
                    'data':text_data_json
                }
            )
        
        

    #New participant arrived in the room
    def newParticipant(self,event):
        self.send(text_data = json.dumps(event['data']))
    
    
    #ByPassFunction sends icecandidates and offer and answers between p2p 
    def ByPassFunction(self,event):
        self.send(text_data=json.dumps(event['data']))
        
        
        
    
        
       
    
    